---
title: 프로그래머스 운영체제 (LV3)[PCCP 모의고사1]
date: 2024-05-08
categories: [알고리즘, 프로그래머스]
tags: [Python,Algorithm,Programmers]
pin : false
---
## 문제
[프로그래머스 운영체제](https://school.programmers.co.kr/learn/courses/15008/15008-pccp-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC-1%ED%9A%8C)

개발자 준모는 운영체제를 만들었습니다. 준모가 만든 운영체제는 프로그램의 우선순위와 호출된 시각에 따라 실행 순서를 결정합니다. 모든 프로그램에는 1부터 10까지의 점수가 매겨져 있으며, 이 점수가 낮을수록 우선순위가 높은 프로그램입니다. 각 프로그램들은 실행 시간이 정해져 있으며 프로그램이 호출되면 대기상태에 있다가 자신의 순서가 되면 실행 시간 동안 실행된 뒤 종료됩니다.

준모가 만든 운영체제는 호출된 프로그램들 중 우선순위가 가장 높은 프로그램을 먼저 실행합니다. 호출된 각 프로그램은 자신보다 우선순위가 높은 호출된 프로그램이 모두 종료된 후에 실행됩니다. 단, 실행 중인 프로그램보다 우선순위가 높은 프로그램이 호출되어도 실행 중이던 프로그램은 중단되지 않고 종료될 때까지 계속 실행됩니다. 또한, 우선순위가 같은 프로그램들 중에서는 먼저 호출된 프로그램이 먼저 실행됩니다.

다음은 1번부터 4번까지의 4개의 프로그램이 호출된 예시입니다.

<div align='center'>
    <img src="../assets/img/programmers/운영체제/problem.png"  height="200px">
</div>

예를 들어, 1번부터 4번까지 4개의 프로그램의 점수가 순서대로 2, 1, 3, 3이며, 호출된 시각은 0, 5, 5, 12초이고, 수행시간은 10, 5, 3, 2라고 가정해 봅시다.

1. 1번 프로그램이 0초에 호출될 때 실행 중인 프로그램이 없으므로, 0초에 1번 프로그램이 바로 실행됩니다. 1번 프로그램은 10초에 종료되며, 2, 3번 프로그램이 새로 호출됩니다. <br><br>
2. 호출된 2, 3번 프로그램 중 2번 프로그램의 점수가 1로 우선순위가 높습니다. 2번 프로그램은 5초에 실행되어 10초에 종료될 때까지 5초 동안 대기했습니다. 2번 프로그램은 15초에 종료되며, 4번 프로그램이 새로 호출됩니다.<br><br>
3. 호출된 3, 4번 프로그램은 점수가 같지만, 3번 프로그램이 먼저 호출되었기 때문에 3번 프로그램이 먼저 실행됩니다. 3번 프로그램은 5초에 호출되어 15초에 실행될 때까지 10초 동안 대기했습니다. 3번 프로그램은 18초에 종료됩니다.<br><br>
4. 4번 프로그램이 마지막으로 실행되며, 4번 프로그램은 12초에 실행되어 18초에 종료될 때까지 6초 동안 대기했습니다. 4번 프로그램은 20초에 종료됩니다.

모든 프로그램이 종료되는 시각은 20초이며, 각 프로그램에 대기한 시간은 순서대로 0, 5, 10, 6초입니다. 점수가 1인 프로그램의 대기시간 합은 5초, 점수가 3인 프로그램의 대기시간 합은 16초 임을 알 수 있습니다.

프로그램들의 정보를 나타내는 2차원 정수 배열 `program`이 주어질 때, 모든 프로그램들이 종료되는 시각과 프로그램의 점수마다 대기시간의 합을 정수 배열에 담아 return 하는 solution 함수를 완성하세요. 

return 해야 하는 `answer` 배열은 길이가 11인 정수 배열입니다. `answer[0]`은 모든 프로그램들이 종료되는 시각을 의미하며, `answer[i]`(1 ≤ i ≤ 10)는 프로그램의 점수가 i인 프로그램들의 대기시간의 합을 의미합니다.

## 제한사항

- 1 ≤ `program` 의 길이 ≤ 100,000
- `program[i]` 은 i+1번 프로그램의 정보를 의미하며, `[a, b, c]`의 형태로 주어집니다.
  - a는 프로그램의 점수를 의미하며, 1 ≤ a ≤ 10 을 만족합니다.
  - b는 프로그램이 호출된 시각을 의미하며, 0 ≤ b ≤ 10,000,000을 만족합니다.
  - c는 프로그램의 실행 시간을 의미하며, 1 ≤ c ≤ 1,000을 만족합니다.
  - a, b쌍이 중복되는 프로그램은 입력으로 주어지지 않습니다. 즉, 호출된 시각이 같으면서 점수도 같은 프로그램은 없습니다.


## 입출력 예


| program                          | result(answer)                        |
|----------------------------------|---------------------------------------|
| [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]] | [20, 5, 0, 16, 0, 0, 0, 0, 0, 0, 0] |
| [[3, 6, 4], [4, 2, 5], [1, 0, 5], [5, 0, 5]]   | [19, 0, 0, 4, 3, 14, 0, 0, 0, 0, 0] |



## 입출력 예 설명

입출력 예 #1
- 문제 예시와 같습니다.

입출력 예 #2
- 그림으로 나타내면 아래 그림과 같습니다.

<div align='center'>
    <img src="../assets/img/programmers/운영체제/input.png"  height="200px">
</div>

## 풀이

```python

# 대기중 딕셔너리 key: 자기 번호 , value : 우선순위, 대기시작 시간
#  딕셔너리중 가

# 일단 숫자들은 1~10 까지 있고
#출력은 최종 종료시간, 숫자 1부터 10까지의 각 대기시간을 한 리스트에출력

#입력은 [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]  첫번쨰는 숫자, 두번째는 호출되는시각, 세번쨰는 수행되는거 걸리는시간

# 입력 길이는 10만개

def solution(program):
    answer_list=[0 for i in range(11)]
    program.sort(key=lambda x: (x[1],x[0]))
    print(program)
    waiting=[]
    now=program.pop()
    call=now[1]
    finish=now[2]
    #wating이 기준이면 풀리겠네
    while program:
        #기다리고 있는게 존재하면
        if waiting:
            # waiting에서 우선순위에 따라 뺴고
            wait=waiting.pop()
            #대기시간 계산해서
            wait_time=finish-wait[1]
            #정답에 추가하고
            answer_list[wait[0]]+=wait_time
            #finish를 갱신한다
            finish+=wait[2]


            #그런다음 남은 program중에서 waiting에 넣을껄 구한다.
            # 남은  program중 finish보다 전에 호출되는 모든 일들은
            while program[0][1] <=finish:
                # waiting에 추가한다.
                waiting.append(program.pop())
                # 다시 waiting을 탐색하기 위해 되돌아 간다.
                continue

        #여기까지왔다는 것은 1. 현재
        while waiting:
            # waiting에서 우선순위에 따라 뺴고
            wait = waiting.pop()
            # 대기시간 계산해서
            wait_time = finish - wait[1]
            # 정답에 추가하고
            answer_list[wait[0]] += wait_time
            # finish를 갱신한다
            finish += wait[2]


        # 이제 다시 제일 첫번째 값을 다시 기준으로 삼아서 위 과정을 반복한다.
        #근데이제, 여기서 waitining
        else :
            start=compared[1]
            end=compared[2]
        #지금 now에 시작되고 끝나기까지 호출되는게 없다면 => 호출된것들, 즉 waiting들을 정리해서 실행시키면됨
        #waiting의 우선순위는 1. 점수 2. 우선 호출 1,2 같다면 암거나 해도될듯
        # waiting중에서 우선순위따라 하나를 골라서 => 개를 다시 now로 하고 비교해야될듯
        else:
            waiting.sort(key=lambda x: (x[0], x[1]))
            wait_now=waiting.pop()
            start=end
            end=end+wait_now[2]

    # start_time=4
    # end_time=start_time+pg[2]
    #이사이에 pg[1]이 존재하는 모든 애들을 가져와야하나?
    # wait_list[]


    answer = []

    return answer


program = [[2, 0, 10], [1, 5, 5], [3, 5, 3], [3, 12, 2]]
program2=[[3, 6, 4], [4, 2, 5], [1, 0, 5], [5, 0, 5]]
solution(program2)
```

## 설명



## 문제에서 얻은 것


