---
title: IOC와 DI란 무엇인가 + Bean객체의 의미
date: 2024-04-27
categories: [개발,스프링, 개념]
tags: [Spring, SpringBoot]  
pin : false
---


## IoC(Inversion of Control), DI(Dependency Injection)

<div align='center'>
    <img src="../assets/img/di_ioc.png"  height="500px">
</div>

- IoC나 DI는 레고와 같은 것이다
  - 스프링이 바닥판처럼 깔려있고, 우리는 그 위에서 멋진 조립(어플리케이션)을 만들면 된다

### DI(의존성 주입)
전통적인 프로그래밍 모델에서는 `객체가 자신의 의존성을 생성하고 관리`한다. 

간단한 예로
```java
public class 청룡언월도 {
    ...
    ...
}
```
```java
public class 관우 {
    private 청룔언월도 언월도=new 청룡언월도();

    public 관우() {
        언월도 = new 청룡언월도();
    }
}
```
이런식으로 `관우 클래스 내부에서 청룡언월도 객체를 생성`했기떄문에 이것은 의존성 주입이아니라
`스스로 의존성을 만든것`이다

하지만 의존성 주입을 적용할 경우

```java
@Component // 스프링 컨테이너에 Bean으로 등록
public class 청룔언월도 {
    ...
    ...
}
```
```java
public class 관우 {
  @Autowired // 스프링 컨테이너에 있는 Gun 타입의 Bean을 주입
  private 청룔언월도 언월도;
}

```
위 코드에 경우 청룡언월도 `객체(Bean)를 스프링 컨테이너에 등록`하고, 스프링 컨테이너에서 관우의 언월도 멤버변수에
`Bean객체를 주입`할 수 있게 해준 것이다.

### IoC(제어의 역전)

스프링에서 우리는 객체의 의존성을 제어의 역전이라는 개념을 통해 주입 받을 수 있다.

IoC에 의미는 다음과 같다.
>스프링 컨테이너가 필요에 따라 개발자 대신 Bean들을 관리(제어)해주는 행위

즉 개발자가 객체들을 제어하는게 아니라, 스프링 컨테이너(IoC container)에서 객체들을 등록하고 제어해주는 것이다.

덕분에 우리는 마치 레고 조립과 같이, 스프링이 기반을 제공하고 개발자는 그 위에 자신의 독특한 애플리케이션을 
조립하면서 접착제에 대한 걱정 없이 집중할 수 있게 되는 것이다.

### IoC Container(스프링 컨테이너)

> 스프링 프레임워크에서 객체를 Bean객체로서 등록하고 의존성을 관리해주는 컨테이너

IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다. 또한 
생성, 의존성 설정, 초기화, 소멸에 대한  LifeCycle(생명주기)를 관리한다.

개발자들이 직접 객체를 생성할 수도 있지만 컨테이너에게 맡긴다. 이렇게 맡김으로서 개발자들은 비즈니스 로직에 더욱 집중할 수 있게 된다.

Spring Container는 크게  `BeanFactory`와 `Application Context`로 나뉜다

#### BeanFactory

빈을 생성하고 의존관계를 설정하는 기능을 담당하는 가장 기본적인 IoC 컨테이너이자 클래스를 말한다.

#### ApplicationContext

ApplicationContext는 BeanFactory를 구현하고 있어 BeanFactory의 확장된 버전이라고 생각하면 좋다.

💡 참고로 '빈 팩토리(BeanFactory)'라고 말할 때는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고,

'애플리케이션 컨텍스트(ApplicationContext)'는 별도의 정보를 참고해서 빈의 생성, 관계 설정 등의 제어를 총괄하는 것에 초점을 맞춘 것이다.

#### BeanFactory VS ApplicationContext

ApplicationContext는 BeanFactory의 모든 기능을 포함하고 + 여러 추가 기능들을 제공해주기 떄문에,

스프링 공식 문서에서도 특별한 이유가 없다면 ApplicationContext를 사용해야 한다고 나와있다.

따라서 이 추가기능들을 사용하는 것보다메모리 소모량 축소가 더욱 중요한 상황이 아니라면 추가 기능을 위해 사용하는 것이 좋다. 추가기능 중 대표적인 것은 아래와 같다.

#### Environment

프로파일(Profile)을 설정하고 어떤 것을 사용할지 선택할 수 있게 해주며, 소스 설정 및 프로퍼티 값을 가져오게 해준다.

즉 local, dev, release, test 등등 여러 프로파일 환경을 설정하고 사용할 수 있게 도움을 준다.

#### MessageSource

메시지에 대한 국제화(i18n)을 제공하는 인터페이스이다.
i18n은 internationalization(국제화)의 약칭으로 소프트웨어가 언어에 종속적이지 않게 하기 위한 인터페이스이다.
메세지 설정 파일을 모아서 각 국가마다 로컬라이징을 함으로써 각 지역에 맞춤 메시지를 제공할 수 있는 것이다.

### Bean

#### 자바에서의 Bean

자바에서 Bean객체란  POJO의 한 형태인 javaBean 객체를 의미하며, 다음과 같은 특징이 있다.

- 데이터를 저장하기 구조체로 자바 빈 규약이라는 것을 따르는 구조체이다


자바 빈 규약 중 중요한 몇가지는 아래와 같다.
- private하게 프로퍼티위한 를 선언하고 getter/setter로만 데이터를 접근한다.
- getter 와 setter는 접근자가 public으로 선언되어야 한다.
- 인수(argument)가 없는 기본 생성자가 있다.
- 직렬화 되어 있어야 한다. (선택사항)

```java
public class JavaBean {
  
	private String id;
	private Integer count;

	public JavaBean(){}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public Integer getCount() {
		return count;
	}

	public void setCount(Integer count) {
		this.count = count;
	}
}
```

#### 스프링에서의 Bean

스프링 프레임워크에서 말하는 Bean 은 조금 더 확장된 의미를 가진다.<br>
스프링에서 Bean 이라고 할 때는, 스프링 IoC컨테이너에 의해 관리되는 객체를 의미한다.

- 스프링 IoC 컨테이너에 의해 생성되고 관리되는 객체
- 자바에서처럼 new Object(); 로 생성하지 않는다
- 각각의 Bean들 끼리는 서로를 편리하게 의존(사용)할 수 있음

<div align='center'>
    <img src="../assets/img/bean.png"  height="500px">
</div>

위 사진 처럼, 실제로 Spring Application Context에서 Bean객체들이 리스트로 등록이 되어있다.

각 객체 A, B, C를 빈으로 등록한다는 것은 단순히 우리가 만들 클래스를 그대로 쓴다는 의미가 아니다.

Spring Application Context는 우리가 만든 클래스에 어노테이션으로 정의한 설정들을 입혀준다.

예를들어 @Controller이면 컨트롤러역할과 관련된 설정을, @Service면 서비스 계층과 관련된 설정을, 아니면 그냥 @Component면 기본 설정 등등을
적용해준다.

또한 각 설정한 어노테이션을 기반으로 객체간의 의존성도 판단해서 객체가 자동으로 빈에 주입된다.

그리고 최종적으로 생성시에는 Scope에 따라 (일반적으로 싱글톤 타입으로) 인스턴스로 실체화 된다. 

### Bean의 등록

- 과거에는 xml로 설정을 따로 관리하여 등록(불편하고 귀찮음)
- 현재는 annotation 기반으로 Bean 등록
  - @Bean, @Controller, @Service

### Bean 등록 시 정보

- Class 경로


- Bean의 이름
  - 기본적으로는 원본 Class 이름에서 첫 문자만 소문자로 변경  → accountService, userDao
  - 원하는 경우 커스텀 가능


- Scope : Bean을 생성하는 규칙
  - singleton : 컨테이너에 단일로 생성
  - prototype: 작업 시마다 Bean을 새로 생성하고 싶을 경우
  - request: http 요청마다 새롭게 Bean을 생성하고 싶은 경우


### Bean LifeCycle callback(빈 생명주기 콜백함수)

- callback : 어떤 이벤트가 발생하는 경우 호출되는 메서드


- lifecycle callback
  - Bean을 생성하고 초기화하고 파괴하는 등 특정 시점에 호출되도록 정의된 


- 주로 많이 사용되는 콜백
  - @PostConstruct : 빈 생성 시점에 필요한 작업을 수행
  - @PreDestroy : 빈 파괴(주로 어플리케이션 종료) 시점에 필요한 작업을 수행

### 아니 그래서 클래스 A가 Bean객체로 등록되면서 정확히 무슨일이 벌어지는 건데?

@Component 어노테이션을 사용해 클래스를 빈(Bean)으로 등록후의 사용, 소멸까지의 LifeCycle을 살펴보겠다.

1. #### 컴포넌트 스캔
   Spring은 애플리케이션 실행 시 @ComponentScan (또는 XML 설정에서 지정한 패키지)을 통해 @Component 어노테이션이 적용된 클래스를 검색한다. 이 과정은 다른 스테레오타입 어노테이션인 @Controller, @Service, @Repository가 적용된 클래스도 포함한다. <br> <br>
2.  #### 빈(Bean) 정의 생성
   @Component가 붙은 클래스를 발견하면, Spring은 해당 클래스에 대한 빈 정의(Bean Definition)를 생선한다. 빈 정의에는 `클래스의 경로`, `빈의 이름`, `빈의 스코프` 등의 정보가 포함된다.<br>
   이떄 Bean의 이름은 기본적으로 클래스 이름을 사용하되 첫 글자를 소문자로 변경되서 사용된다.(예: AccountService → accountService) 원한다면 @Component("customName")과 같이 이름을 명시적으로 지정할 수도 있다. <br> <br>
3. #### 스코프 결정
   빈의 스코프를 결정한다. @Scope 어노테이션을 사용하여 명시적으로 스코프를 지정하지 않는 경우, 기본적으로 singleton 스코프가 적용된다. 다른 스코프 옵션으로는 prototype, request, session, globalSession 등이 있따. 이 스코프 결정은 `빈의 생명주기`와 `생성 방법`을 결정하는 데 중요한 역할을 한다. <br> <br>
4. #### 의존성 주입 설정
   빈 정의가 생성된 후, Spring은 클래스 내에 선언된 @Autowired, @Resource, @Inject 등의 어노테이션을 통해 의존성 주입이 필요한 필드, 생성자 또는 메서드를 파악한다. 이를 통해 해당 빈이 다른 빈들과 어떻게 연결되어야 하는지 결정한다. <br> <br>
5. #### 빈 인스턴스 생성
   설정된 스코프에 따라 빈 인스턴스를 생성한다. singleton의 경우, 애플리케이션 컨텍스트 내에서 단 하나의 인스턴스만 생성되며, 이 인스턴스는 필요할 때마다 재사용된다. prototype 스코프의 경우, 요청마다 새로운 인스턴스가 생성된다. <br> <br>
6. #### 초기화 및 후처리
   빈이 생성되고 의존성이 주입된 후, 초기화 메서드가 호출된다. 클래스에서 @PostConstruct 어노테이션이 적용된 메서드를 초기화 메서드로 사용할 수 있다. 또 다른 예로, BeanPostProcessor 인터페이스를 구현한 후처리기를 통해 빈 인스턴스의 후처리 작업을 수행할 수 있습니다. <br> <br>
7. #### 애플리케이션 컨텍스트에 등록
   최종적으로, 모든 설정이 완료된 빈 인스턴스는 Spring의 애플리케이션 컨텍스트에 등록되며, 애플리케이션 전반에서 사용할 준비가 됩니다.
   이 과정을 통해, Spring은 @Component 어노테이션이 적용된 클래스를 자동으로 찾아 빈으로 등록하고 관리하며, 애플리케이션의 다양한 부분에서 이 빈을 사용할 수 있도록 합니다. 이는 개발자가 수동으로 객체를 생성하고 관리하는 복잡성을 줄이고, 코드의 모듈성과 유지보수성을 높이는 데 크게 기여합니다.



빈 인스턴스 생성: 스프링 컨테이너는 빈 정의에 따라 객체를 생성합니다. 이 단계에서 객체의 메모리 할당이 이루어지고, 생성자가 호출됩니다.
의존성 주입: 빈 인스턴스 생성 후, 스프링은 @Autowired, @Resource, @Inject 등의 어노테이션을 통해 의존성을 주입합니다. 필드 주입, 세터 주입 또는 생성자 주입 방식을 통해 의존성이 필요한 객체를 연결합니다.
초기화 콜백 메소드 호출: 의존성 주입이 완료된 후, 초기화 콜백 메소드가 호출됩니다. @PostConstruct 어노테이션을 사용하거나 InitializingBean 인터페이스의 afterPropertiesSet() 메소드를 구현하여 초기화 로직을 수행할 수 있습니다.
사용: 애플리케이션 내에서 스프링 빈이 필요할 때마다 스프링 컨테이너에서 빈을 조회하여 사용합니다.
소멸 전 콜백 메소드 호출: 컨테이너가 종료되기 전에 빈의 소멸 전 콜백 메소드가 호출됩니다. @PreDestroy 어노테이션을 사용하거나 DisposableBean 인터페이스의 destroy() 메소드를 구현하여 소멸 로직을 수행할 수 있습니다.
스프링 종료: 애플리케이션이 종료되면 스프링 컨테이너는 모든 빈의 소멸 과정을 관리하고 자원을 정리합니다.


왜? 그 기술 / 기술스택을 사용했는가
- 왜? A라는 기능에서 해당 로직을 사용했는가
- 왜? 자료구조 A를 사용하지 않고 자료구조 B를 사용했는가
- 왜? A라는 문제를 해결하기 위해 B라는 해결책을 사용했는가
- 왜? 그런 생각을 했고 그런 판단을 했는가
 
