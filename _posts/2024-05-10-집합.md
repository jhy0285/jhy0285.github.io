---
title: 백준 집합 [11723번]
date: 2024-05-06
categories: [알고리즘, 백준]
tags: [Python,Algorithm,Baekjoon]
pin : false
---
## 문제

비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.

- add x : S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
- remove x : S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
- check x : S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
- toggle x : S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
- all : S를 {1, 2, ..., 20}으로 바꾼다.
- empty : S를 공집합으로 바꾼다.

## 입력

첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.

둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.

## 출력

check 연산을 제외한 나머지, 결과를 출력한다.


## 예제 입출력

<table>
  <tr>
    <td>
      <table>
        <tr>
          <th>예제 입력</th>
        </tr>
        <tr>
          <td>26</td>
        </tr>
        <tr>
          <td>add 1</td>
        </tr>
        <tr>
          <td>add 2</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
        <tr>
          <td>check 2</td>
        </tr>
        <tr>
          <td>check 3</td>
        </tr>
        <tr>
          <td>remove 2</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
        <tr>
          <td>check 2</td>
        </tr>
        <tr>
          <td>toggle 3</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
        <tr>
          <td>check 2</td>
        </tr>
        <tr>
          <td>check 3</td>
        </tr>
        <tr>
          <td>check 4</td>
        </tr>
        <tr>
          <td>all</td>
        </tr>
        <tr>
          <td>check 10</td>
        </tr>
        <tr>
          <td>check 20</td>
        </tr>
        <tr>
          <td>toggle 10</td>
        </tr>
        <tr>
          <td>remove 20</td>
        </tr>
        <tr>
          <td>check 10</td>
        </tr>
        <tr>
          <td>check 20</td>
        </tr>
        <tr>
          <td>empty</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
        <tr>
          <td>toggle 1</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
        <tr>
          <td>toggle 1</td>
        </tr>
        <tr>
          <td>check 1</td>
        </tr>
      </table>
    </td>
    <td>
      <table>
        <tr>
          <th>예제 출력</th>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>0</td>
        </tr>
        <tr>
          <td>1</td>
        </tr>
        <tr>
          <td>&nbsp;</td> </tr>
        <tr>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>&nbsp;</td>
</tr>
                </tr>
        <tr>
        </tr>
      </table>
    </td>
  </tr>
</table>








## 풀이

```python
from itertools import permutations
def solution(ability):
  answer = 0

  p = list(permutations(ability, len(ability[0])))

  print(p)
  for i in range(len(p)):
    total = 0
    for j in range(len(p[i])):
      total += p[i][j][j]
    answer = max(answer, total)

  return answer
```

## 설명


|      | 테니스 | 탁구 | 수영 |
|------|--------|------|------|
| 석환 | 40     | 10   | 10   |
| 영재 | 20     | 5    | 0    |
| 인용 | 30     | 30   | 30   |
| 정현 | 70     | 0    | 70   |
| 준모 | 100    | 100  | 100  |

이런식으로 테이블이있을떄, 테이블의 가로,세로 최대길이가 10이므로, `완전탐색`으로 풀려고 접근하였다.

즉, 선수들이 서로 종목이 겹치지 않게 대회에 참가하는 모든 경우의 수를 구해서, 그중 가장 큰값을 구하면 되는 것이다.

필자는 처음에 종목별로 하나식 뽑아서 모든 경우의 수를 구하려 했으나, 주어지는 ability배열이 선수별로 종목에대한 능력치가 주어져있었다.

즉 가로로 한줄씩 주어져있던 것이다.

그럼 생각을 바꿔서,

|      | 테니스 | 탁구 | 수영 |
|------|--------|------|------|
| 석환 | 40     | 10   | 10   |

이렇게 가로로 한줄씩, 종목의 갯수(n이라하자)만큼 뽑은 배열을 구한다음 그것에 (0,0), (1,1), (2,2,)..(n-1,n-1)을 뽑으면 모든 경우의 수를 구해보는 것과 같다

이해하기 위해 표로 다시 표현하자면

|      | 테니스 | 탁구 | 수영 |
|------|--------|------|------|
| <span style="background-color:yellow">석환</span> | <span style="background-color:yellow">40</span>     | <span style="background-color:yellow">10</span>   | <span style="background-color:yellow">10</span>   |
| <span style="background-color:yellow">영재</span> | <span style="background-color:yellow">20</span>     | <span style="background-color:yellow">5</span>    | <span style="background-color:yellow">0</span>    |
| 인용 | 30     | 30   | 30   |
| <span style="background-color:yellow">정현</span> | <span style="background-color:yellow">70</span>     | <span style="background-color:yellow">0</span>    | <span style="background-color:yellow">70</span>   |
| 준모 | 100    | 100  | 100  |

이렇게 종목 수인 3개 만큼 뽑는 `모든 경우의 수를 순서를 고려하여` 구한 다음
그중 능력치가 최대인 값을 찾으면 된다.

위 예시에서는 `5개중 3개를 순서를 고려하여 뽑으니 5P3`이 된다.

그렇게 구한 5P3=60개의 순서를 하나식 순회해서
종목의 갯수, 즉 여기서는 3개이므로 (0,0),(1,1),(2,2)를 모든 경우에 대해 고른다면,
결국 모든 경우를 구하는 것과 같다

## 문제에서 얻은 것



|      | 테니스 | 탁구 | 수영 |
|------|--------|------|------|
| 석환 | 40     | 10   | 10   |
| 영재 | 20     | 5    | 0    |
| 인용 | 30     | 30   | 30   |
| 정현 | 70     | 0    | 70   |
| 준모 | 100    | 100  | 100  |

이러한 2차원 테이블에서 서로다른걸 선택하는 경우를 고려할 경우,

일반적으로 세로로, 즉 여기서는 종목별로 하나식 고려해보는게 일반적이지만,

가로로, 즉 여기서는 사람(선수)별로 하나식 골라보는 경우도 생각해볼수 있다.

가로든 세로든 상관없다. 생각에 제한을 두지 말자. 자유롭게 데이터를 가지고 놀수 있어야한다
