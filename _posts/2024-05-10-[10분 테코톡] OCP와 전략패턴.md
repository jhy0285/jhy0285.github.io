---
title: [10분 테코톡] OCP와 전략패턴
date: 2024-05-10
categories: [CS, 개념]
tags: [10분 테코톡, 패턴]
pin : false
---
> 유튜브에 올라와 있는 10분 테코톡을 하루에 하나식 듣고 정리합니다.</br>
> 추가적인 궁금점이나 찾아볼 것이 있다면, 추가해서 기록합니다.

[[10분 테코톡] 👾베디의 OCP와 전략패턴](https://www.youtube.com/watch?v=90ZDvHl8ROE&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=459&t=47s)

# OCP와 전략패턴


## if-else의 문제점

- 변경확장이 될 수록 코드가 복잡해진다.
- 코드를 수정하거나 수정할 위치를 찾는데 점점 오래 걸린다.
- 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다.

```java
public List<Integer> generateLotto() {
  List<Integer> numbers = new ArrayList<>();
  for (int i = 1; i <= LOTTO_NUMBER_MAX; i++) {
    numbers.add(i);
  }

  if (shuffle == RANDOM) {
    Collections.shuffle(numbers);
  } else if (shuffle == NOTHING) {
    // 아무것도 하지 않음
  } else if (shuffle == REVERSE) {
    Collections.shuffle(numbers);
    Collections.reverse(numbers);
  } else if (shuffle == TEN_TO_TWENTY) {
    Collections.shuffle(numbers.subList(10, 21)); // 11~20 셔플
  } else if (shuffle == TWENTY_TO_THIRTY) {
    Collections.shuffle(numbers.subList(20, 31)); // 21~30 셔플
  } // ... (필요에 따라 추가)

  return numbers.subList(0, LOTTO_NUMBER_SIZE);
}
```

위의 예시는 랜덤 로또 번호를 만드는 코드이다. suffle변수의 값을 조건식으로 분기를 나눠서
다른 로직을 수행하는데, 초기에는 if-else블록이 크지않기 떄문에 이 방법으로 빠르게 구현해 나갈 수 있다.


하지만 나중에 **if-else 블록이 점점 커져서** 수백 줄 이상으로 빠르게 증가하면 코드가 복잡해지고, 
특정 분기에 로직을 변경해야 할때 **해당되는 부분을 찾아서 수정하기가 쉽지 않아진다**.

그리고 개발을 하다보면 시간이 없어서 해당 if-else 로직구문을 그대로 다른곳에서 붙여넣어서 사용하고, 나중에 리팩토링해야지 라는 생각을 종종 하게 된다.

예를들어, 해당 if-else 로직구문을 쓰는 곳이 A, B, C파일이 있다면, 해당 로직구문에 변경이 있을때 그걸 일일히 A, B, C파일에 반영해줘야 하는데, 이떄 **누락이 생길 위험**도 있다.

이런 문제점들은 객체지향설계의 5대 원칙인 SOLID중에 하나인 OCP를 준수하지 않아서 그런 것인데, OCP가 무엇인지와 해결방법은 뭔지 알아보도록 하자.

## OCP란?

Open Close Principle: 개방폐쇄의 원칙

소프트웨어 구성 요소(컴포넌트, 클래스, 모듈, 함수 등)는 확장에 대해서는 개방되어야 하지만 **수정에 대해서는 폐쇄되어야 한다.**

**기존의 코드를 변경하지 않으면서** 기능을 추가할 수 있도록 설계가 되어야 한다는 뜻이다.

앞에 로또 번호 코드를 다시 살펴보자 

```java
public List<Integer> generateLotto() {
  List<Integer> numbers = new ArrayList<>();
  for (int i = 1; i <= LOTTO_NUMBER_MAX; i++) {
    numbers.add(i);
  }

  if (shuffle == RANDOM) {
    Collections.shuffle(numbers);
  } else if (shuffle == NOTHING) {
    // 아무것도 하지 않음
  } else if (shuffle == REVERSE) {
    Collections.shuffle(numbers);
    Collections.reverse(numbers);
  } else if (shuffle == TEN_TO_TWENTY) {
    Collections.shuffle(numbers.subList(10, 21)); // 11~20 셔플
  } else if (shuffle == TWENTY_TO_THIRTY) {
    Collections.shuffle(numbers.subList(20, 31)); // 21~30 셔플
  } // ... (필요에 따라 추가)

  return numbers.subList(0, LOTTO_NUMBER_SIZE);
}
```
여기서 **앞뒤 절반을 각각 섞는 셔플 방식**을 추가한다고 가정해 보자. 이를 HALF_SHUFFLE이라는 값으로 표현해보겠다.

```Java
// ... (기존 코드)
else if (shuffle == HALF_SHUFFLE) {
  int half = numbers.size() / 2;
  Collections.shuffle(numbers.subList(0, half));
  Collections.shuffle(numbers.subList(half, numbers.size()));
}

// ... (기존 코드)
```


위 코드처럼 새로운 셔플 방식을 추가하려면 generateLotto() **함수 내부의 if-else 문을 직접 수정해야 한다**

이는 기존의 코드를 변경하지 않으면서 기능을 추가해야하는 OCP원칙을 위반하는 것이다.

그럼 이 OCP원칙을 적용시키려면 어떻게 해야될까?

첫번재는 상속이 있고, 두번째는 컴포지션이 있다.

- 상속(is-a): 부모 클래스의 기능을 확장하는 자식 클래스를 생성하여 새로운 기능을 추가한다. 자식 클래스는 부모 클래스의 특징을 물려받으면서 새로운 기능을 추가할 수 있다.


- 컴포지션(has-a): 기존 클래스의 객체를 포함하는 새로운 클래스를 생성하여 기능을 확장한다. 새로운 클래스는 포함된 객체의 기능을 활용하면서 새로운 기능을 추가할 수 있다.

해당 강연자(베디)는 상속대신 컴포지션을 사용하기로 하였다. 그 이유로 **깨지기 쉬운 상위클래스 문제**를 언급하였다.


## 깨지기 쉬운 상위클래스 문제란?

추가 예정


## 컴포지션의 적용방법 3가지

- 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
- 이 두 모듈이 만나는 지점에 인터페이스를 정의
- 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성

